push!() - adds into array []
append!() - can add multiple elements into array 
rand() - chooses random thing from array, possible
isa() - check if correct data structure

https://www.baeldung.com/cs/tetris-piece-rotation-algorithm
https://github.com/jonhoo/tetris-tutorial/blob/master/doc/code.md

https://github.com/dillondaudert/Tetris.jl/tree/main

https://github.com/aviks/GameZero.jl/tree/master/example/BasicGame 

Chat deepcopy notes:

    ### üîπ **What is `deepcopy()`?**

    `deepcopy(obj)` creates a **completely new copy** of `obj`, including **all objects inside it** (recursively).  
    It means:  
    > Not just the container is copied ‚Äî everything nested inside (arrays, dictionaries, structs...) is **also copied**, so the new object is **entirely independent**.

    ---

    ### ‚ö° **Why does this matter?**

    By default in Julia, **mutable objects (like arrays)** are passed and assigned **by reference**.

    Example (without `deepcopy`):

    ```julia
    a = [1, 2, 3]
    b = a        # just another reference to the same array
    b[1] = 99

    println(a)   # Output: [99, 2, 3]  ‚Äî> a also changed!
    ```

    If you want **a real, independent copy**, you use `deepcopy`:

    ```julia
    a = [1, 2, 3]
    b = deepcopy(a)
    b[1] = 99

    println(a)   # Output: [1, 2, 3]  ‚Äî> a is untouched
    println(b)   # Output: [99, 2, 3]
    ```

    ---

    ### üß© **Shallow copy vs Deep copy**

    | Method           | What it copies |
    |------------------|----------------|
    | `copy(obj)`      | **Shallow copy**: copies the container, but elements inside still point to the same objects |
    | `deepcopy(obj)`  | **Deep copy**: copies container **and** all nested objects |

    Example:

    ```julia
    a = [[1, 2], [3, 4]]
    b = copy(a)          # shallow copy
    b[1][1] = 99

    println(a)   # Output: [[99, 2], [3, 4]]  ‚Äî> inner array was shared!
    ```

    Now with `deepcopy`:

    ```julia
    a = [[1, 2], [3, 4]]
    b = deepcopy(a)
    b[1][1] = 99

    println(a)   # Output: [[1, 2], [3, 4]]  ‚Äî> a is safe
    ```

    ---

    ### ‚ö†Ô∏è **When should you actually use `deepcopy()`?**

    - When you need a **completely independent copy** of a complex object (like a board game state, graph, or nested array), and you plan to **mutate** it.
    - Especially useful in **backtracking algorithms**, **undo/redo functionality**, or **cloning data structures**.

    ---

    ### üö´ **When *not* to use `deepcopy()`**

    - **Avoid blindly using it everywhere** ‚Äî it can be **slow** for large or complex structures because it has to recursively copy *everything*.
    - If you don‚Äôt plan to mutate nested elements, `copy()` or simple assignment might be enough.

    ---

    ### üìù **One-line definition**

    > **`deepcopy(obj)` creates an entirely independent clone of `obj`, recursively copying everything inside it ‚Äî so changing one won't affect the other.**

    ---

≈°patnƒõ v gitu adres√°≈ô(je tam adres√°≈ô a pod adres√°≈ô)
konkr√©tn√≠ enviroment

- tab nastaven√≠

multiple dispatch 
- zobecnenni OOP, 
v OOP (je single dispatch)
https://en.wikipedia.org/wiki/Multiple_dispatch

makro @which, rekne mi kterou implementaci fce mi to zavola

neco jako enum v RUSTu(?)

Erasmus (ktery neni erasmus): 
- nekde nejake schuze
- univerzitni portalz
