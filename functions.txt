push!() - adds into array []
append!() - can add multiple elements into array 
rand() - chooses random thing from array

isa() - check if correct data structure

https://www.baeldung.com/cs/tetris-piece-rotation-algorithm
https://github.com/jonhoo/tetris-tutorial/blob/master/doc/code.md

https://github.com/dillondaudert/Tetris.jl/tree/main

https://github.com/aviks/GameZero.jl/tree/master/example/BasicGame 

Sure! Letâ€™s get into **`deepcopy()`** â€” itâ€™s a simple but *very important* tool in Julia when you want to **fully duplicate an object**, not just pass around references.

---

### ğŸ”¹ **What is `deepcopy()`?**

`deepcopy(obj)` creates a **completely new copy** of `obj`, including **all objects inside it** (recursively).  
It means:  
> Not just the container is copied â€” everything nested inside (arrays, dictionaries, structs...) is **also copied**, so the new object is **entirely independent**.

---

### âš¡ **Why does this matter?**

By default in Julia, **mutable objects (like arrays)** are passed and assigned **by reference**.

Example (without `deepcopy`):

```julia
a = [1, 2, 3]
b = a        # just another reference to the same array
b[1] = 99

println(a)   # Output: [99, 2, 3]  â€”> a also changed!
```

If you want **a real, independent copy**, you use `deepcopy`:

```julia
a = [1, 2, 3]
b = deepcopy(a)
b[1] = 99

println(a)   # Output: [1, 2, 3]  â€”> a is untouched
println(b)   # Output: [99, 2, 3]
```

---

### ğŸ§© **Shallow copy vs Deep copy**

| Method           | What it copies |
|------------------|----------------|
| `copy(obj)`      | **Shallow copy**: copies the container, but elements inside still point to the same objects |
| `deepcopy(obj)`  | **Deep copy**: copies container **and** all nested objects |

Example:

```julia
a = [[1, 2], [3, 4]]
b = copy(a)          # shallow copy
b[1][1] = 99

println(a)   # Output: [[99, 2], [3, 4]]  â€”> inner array was shared!
```

Now with `deepcopy`:

```julia
a = [[1, 2], [3, 4]]
b = deepcopy(a)
b[1][1] = 99

println(a)   # Output: [[1, 2], [3, 4]]  â€”> a is safe
```

---

### âš ï¸ **When should you actually use `deepcopy()`?**

- When you need a **completely independent copy** of a complex object (like a board game state, graph, or nested array), and you plan to **mutate** it.
- Especially useful in **backtracking algorithms**, **undo/redo functionality**, or **cloning data structures**.

---

### ğŸš« **When *not* to use `deepcopy()`**

- **Avoid blindly using it everywhere** â€” it can be **slow** for large or complex structures because it has to recursively copy *everything*.
- If you donâ€™t plan to mutate nested elements, `copy()` or simple assignment might be enough.

---

### ğŸ“ **One-line definition**

> **`deepcopy(obj)` creates an entirely independent clone of `obj`, recursively copying everything inside it â€” so changing one won't affect the other.**

---

If you want, I can show a **concrete board game example** where `deepcopy()` is useful. Want to see that? ğŸ²


Å¡patnÄ› v gitu adresÃ¡Å™(je tam adresÃ¡Å™ a pod adresÃ¡Å™)
konkrÃ©tnÃ­ enviroment

- podÃ­vat se na tabulÃ¡turÃ¡torovÃ© nastavenÃ­ (dat tam 4 mezery misto opravdoveho tab)

upgrady: 
- zobrazit dalÅ¡Ã­ kostiÄku
- udÄ›lat omezenÃ­ na prohazovÃ¡nÃ­
-DONE misto str udelat ciselnou reprezentaci

multiple dispatch 
- zobecnenni OOP, 
v OOP (je single dispatch)


makro @which, rekne mi kterou implementaci fce mi to zavola

neco jako enum v RUSTu(?)

Erasmus: 
- kouknout jestli jsou nejake schuze
- kouknout na univerzitni portalz
